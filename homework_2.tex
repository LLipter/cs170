% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx,enumerate}

\def\Name{Ran Liao}  % Your name
\def\SID{3034504227}  % Your student ID number
\def\Homework{2} % Number of Homework
\def\Session{Spring 2019}


\title{CS170--Spring 2019 --- Homework \Homework\ Solutions}
\author{\Name, SID \SID}
\markboth{CS170--\Session\  Homework \Homework\ \Name}{CS170--\Session\ Homework \Homework\ \Name}
\pagestyle{myheadings}
\date{}

\newenvironment{qparts}{\begin{enumerate}[{(}a{)}]}{\end{enumerate}}
\def\endproofmark{$\Box$}
\newenvironment{proof}{\par{\bf Proof}:}{\endproofmark\smallskip}

\textheight=9in
\textwidth=6.5in
\topmargin=-.75in
\oddsidemargin=0.25in
\evensidemargin=0.25in


\begin{document}
\maketitle
Collaborators: Yilin Wu, Jingyi Xu, Renee Pu

\section{Study Group}
\begin{tabular}{ll}
    Name        &   SID         \\\hline
    Ran Liao    &   3034504227  \\  
    Yilin Wu    &   3034503863  \\
    Jingyi Xu   &   3032003885  \\
    Renee Pu    &   3032083302  \\
\end{tabular}



\newpage
\section{Three Part Solution}

\newpage
\section{Asymptotic Complexity Comparisons}
\begin{qparts}
\item 
$3 \leq  7 \leq 2 \leq 5 \leq 4 \leq 9 \leq 8 \leq 6 \leq 1$

\item 
\renewcommand{\theenumii}{\roman{enumii}}
\begin{enumerate}
  \item $\log_3n = \Theta(\log_4n)$
  
  Proof:
  \[
	 \log_3n  =  \log_{(4^{\log_4 3})}n = (\frac{1}{\log_4 3})\log_4n = \Theta(\log_4n)
 \]
  \item $n\log(n^4) = O(n^2\log(n^3))$
  
  Proof:
 \[
  	\lim_{n \to +\infty} \frac{n^2\log(n^3)}{n\log(n^4)} = \lim_{n \to +\infty} \frac{3n^2\log n}{4n\log n} = \lim_{n \to +\infty} \frac{3}{4}n = \infty
 \]
 
 \item $\sqrt{n} = \Omega((\log n)^3)$
 
 Proof: (Use L\textquotesingle Hôpital's rule)
 \begin{align*}
 	\lim_{n \to+\infty} \frac{\sqrt{n}}{(\log n)^3} 
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{3(\log n)^2\frac{1}{n}} = \lim_{n \to+\infty} \frac{\sqrt{n}}{(\log n)^2} \\
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{2(\log n)\frac{1}{n}} = \lim_{n \to+\infty} \frac{\sqrt{n}}{\log n} \\
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{\frac{1}{n}} = \lim_{n \to+\infty} \sqrt{n} = \infty
 \end{align*}
 
 \item $2^n = \Theta(2^{n+1})$
 
 Proof:
 \[
 	2^{n+1} = 2 * 2^n = \Theta(2^n)
 \]
 
 \item $n = \Omega((\log n)^{\log \log n})$
 
 Proof:
 
 Let $x = \log n$, therefore, $n = 2^x$ and $(\log n)^{\log \log n} = x^{\log x}$
 \[
 	\lim_{n \to+\infty} \frac{n}{(\log n)^{\log \log n}} = \lim_{x \to+\infty} \frac{2^x}{ x^{\log x}} = \infty
 \]
 
 \item $n + \log n = \Theta(n + (\log n)^2)$
 
 Proof:(Use L\textquotesingle Hôpital's rule)
  \begin{align*}
  	\lim_{n \to+\infty} \frac{n + \log n}{n + (\log n)^2}
		&= \lim_{n \to+\infty} \frac{1 + \frac{1}{n}}{1 + 2(\log n)\frac{1}{n}} = \lim_{n \to+\infty}\frac{n +1}{n + 2\log n} \\
		&= \lim_{n \to+\infty} \frac{1}{1 + \frac{2}{n}} = 1
   \end{align*}
   
  \item $\log (n!) = \Theta(n\log n)$
  
  Proof: By Stirling's approximation, actually $n\log n$ and $\log n!$ are equivalent when $n$ is large enough.
 
\end{enumerate}

\end{qparts}

\newpage
\section{In Between Functions}

Disproof:

Consider the following function, this is a counterexample to the claim.
\begin{equation*}
	f(n) = \lfloor 2^{\sqrt{n}} \rfloor 
\end{equation*}

Since for $\forall c>0$
\begin{equation}
	\lim_{n \to+\infty} \frac{\lfloor 2^{\sqrt{n}} \rfloor} {n^c} = +\infty \label{eq4} \
\end{equation}

By \eqref{eq4}, first part of claim doesn't hold. This can be proved by keep using L\textquotesingle Hôpital's rule. 

In the meantime, for $\forall \alpha > 1$
\begin{equation}
	\lim_{n \to +\infty} \frac{\alpha^n}{\lfloor 2^{\sqrt{n}}\rfloor} = \lim_{n \to +\infty} \left(  \frac{\alpha^{\sqrt{n}}}{2} \right)^{\sqrt{n}}= +\infty \label{eq5} \
\end{equation}

By \eqref{eq5}, second part of claim doesn't hold.

\newpage
\section{Bit Counter}

\begin{tabular}{l | c}
    n	&   \# Total Flips  \\\hline
    1  &   1  \\  
    2  &   4  \\
    3  &   11 \\
    4  &   26 \\
\end{tabular}

There're two stages when counting from 0 to $2^n-1$ for a n-bit counter. 

\begin{itemize}
	\item Stage1 : when most-significant bit is 0
	\item Stage2 : when most-significant bit is 1
\end{itemize}

Suppose $f(n)$ represents the total number of flips need for n-bit long counter. Both in stage 1 and 2, $f(n-1)$ flips is needed to flip all bits to 1 except the most-significant bit. When switching between stage 1 and 2, another $n$ flips is introduced. 1 flip to switch the most-significant bit from 0 to 1. $n-1$ flips needed to switch all other bits to 0. Therefore, we have the following recursive formula:
\[
	f(n) = 2f(n-1) + n
\]
To solve this formula, we keep using it recursively, providing $f(1) = 1$ as base case:
 \begin{align}
 	f(n) 	&= 2f(n-1) + n \nonumber \\
		&= 4f(n-2) + 2(n-1) + n \nonumber \\
		&= 8f(n-3) + 4(n-2) + 2(n-1) + n \nonumber \\
		&= 2^kf(n-k) + 2^{k-1}(n-k+1) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \nonumber \\
		&= 2^{n-1}f(1) + 2^{n-2}(2) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \nonumber  \\
		&= 2^{n-1}(1) + 2^{n-2}(2) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \label{eq1} 
 \end{align}
Then we multiply \eqref{eq1} by 2:
 \begin{align}
	2f(n) =  2^{n}(1) + 2^{n-1}(2) + \ldots + 2^3(n-2) + 2^2(n-1) + 2^1(n-0) \label{eq2}  
 \end{align}
By \eqref{eq2} - \eqref{eq1}, we have
 \begin{align*}
 	2f(n) - f(n) &= 2^n + 2^{n-1} + \ldots + 2^1 -n \\
	f(n)		&= \frac{2(1-2^n)}{1-2} - n \\
			&= 2^{n+1} - n - 2 \\
			&= \Theta(2^n)
  \end{align*}
  
  \newpage
  \section{Recurrence Relations}
 Master theorem:
 
Suppose $a, b, c \in \mathbb{R}^+$, $b > 1$ and $T(1)=1$

Given
 \begin{equation*}
 T(n) = aT(\frac{n}{b}) + \Theta(n^c),
 \end{equation*}
 
 We have
\[
 T[n]=\left\{
\begin{array}{lcl}
\Theta(n^{\log_ba})      &      & c < \log_ba\\
\Theta(n^c\log_2n)    &      & c = \log_ba\\
\Theta(n^c)     &      & c > \log_ba\\
\end{array} \right. 
\]

\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
	\item 
	Let $a=4, b=2, c=1$. Since $\log_ba = log_2 4 = 2 > c$, $T(n) = \Theta(n^{\log_ba}) = \Theta(n^2)$.
	\item 
	Let $a=4, b=3, c=2$. Since $\log_ba = log_3 4 < c$, $T(n) = \Theta(n^c) = \Theta(n^2)$.
	\item
	\begin{align*}
		T(n) &= T(\sqrt{n}) + 1 \\
			&= T(n^\frac{1}{2^1}) + 1 \\
			&= T(n^\frac{1}{2^2}) + 1 + 1 \\
			&= T(n^\frac{1}{2^k}) + k \\
	\end{align*}
	This recursion process ends when $n^\frac{1}{2^k}$ reaches 2.
	\begin{align*}
		n^\frac{1}{2^k} &= 2 \\
		\frac{1}{2^k} &= \log_n2  \\
		2^k &= \log_2n \\
		k &= \log_2 \log_2n  \\
	\end{align*}
	Therefore, $T(n) = \Theta(\log \log n)$
\end{enumerate}


  \newpage
  \section{Hadamard matrices}
  
\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
	\item 
	\[
		H_0=
		\begin{bmatrix} 
			1 \\
		\end{bmatrix}
	\]
	\[
		H_1=
		\begin{bmatrix} 
			1 & 1 \\ 
			1 & -1 
		\end{bmatrix}
	\]
		\[
		H_2=
		\begin{bmatrix} 
			1 & 1 & 1 & 1 \\ 
			1 & -1 & 1 & -1 \\ 
			1 & 1 & -1 & -1 \\
			1 & -1 & -1 & 1 \\
		\end{bmatrix}
	\]
	
	\item 
	\[
		H_2v = 
		\begin{bmatrix} 
			1 & 1 & 1 & 1 \\ 
			1 & -1 & 1 & -1 \\ 
			1 & 1 & -1 & -1 \\
			1 & -1 & -1 & 1 \\
		\end{bmatrix}
		\begin{bmatrix} 
			1  \\ 
			-1  \\ 
			-1  \\
			1  \\
		\end{bmatrix}
		=
		\begin{bmatrix} 
			0  \\ 
			0  \\ 
			0  \\
			4  \\
		\end{bmatrix}
	\]
	
	\item 
	\begin{align*}
		u_1 &= H_1(v_1 + v_2) \\
			&= 
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				(
				\begin{bmatrix} 
					1  \\ 
					-1 \\
				\end{bmatrix}
				+
				\begin{bmatrix} 
					-1  \\ 
					1 \\
				\end{bmatrix}	
				)	\\	
			&= 	
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				\begin{bmatrix} 
					0  \\ 
					0 \\
				\end{bmatrix}	\\
			&= 
				\begin{bmatrix} 
					0  \\ 
					0 \\
				\end{bmatrix}					
	\end{align*}
	\begin{align*}
		u_2 &= H_1(v_1 - v_2) \\
			&= 
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				(
				\begin{bmatrix} 
					1  \\ 
					-1 \\
				\end{bmatrix}
				-
				\begin{bmatrix} 
					-1  \\ 
					1 \\
				\end{bmatrix}	
				)	\\	
			&= 	
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				\begin{bmatrix} 
					2  \\ 
					-2 \\
				\end{bmatrix}	\\
			&= 
				\begin{bmatrix} 
					0  \\ 
					4 \\
				\end{bmatrix}					
	\end{align*}
	\[
		u =
		\begin{bmatrix}
			u_1 \\
			u_2 \\
		\end{bmatrix}
		=
		\begin{bmatrix}
			0 \\
			0 \\
			0 \\
			4 \\
		\end{bmatrix}		
	\]
	
	$u$ is identical to $H_2v$
	
	\item
	\begin{align}
		H_kv &= 			
				\begin{bmatrix} 
					H_{k-1} & H_{k-1} \\ 
					H_{k-1} & -H_{k-1} \\ 
				\end{bmatrix}
				\begin{bmatrix}
					v_1 \\
					v_2 \\
				\end{bmatrix} \nonumber \\
			&= 
				\begin{bmatrix} 
					H_{k-1}v_1 + H_{k-1} v_2 \\ 
					H_{k-1}v_1 - H_{k-1} v_2 \\ 
				\end{bmatrix} \label{eq3} 	\\
			&= 		
				\begin{bmatrix} 
					H_{k-1}(v_1 + v_2)  \\ 
					H_{k-1}(v_1 - v_2) \nonumber   \\ 
				\end{bmatrix}	
	\end{align}
	
	\item
	
	\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Main idea}
		
		This is a recursive algorithm. 
		
		If the length of $v$ is 1, just return $H_0v$ immediately. This is the base case.
		
		Otherwise, let $v_1$ and $v_2$ be the top and bottom half of the vector $v$, respectively. Invoke this algorithm recursively to compute $H_{k-1}v_1$ and $H_{k-1}v_2$. Return $									\begin{bmatrix} 
					H_{k-1}v_1  + H_{k-1}v_2\\ 
					H_{k-1}v_1  -  H_{k-1}v_2 \\ 
				\end{bmatrix}$ as result.
		\item \textbf{Proof of correctness}
		
		By \eqref{eq3}, this strategy is correct mathematically.
		\item \textbf{Running time}
		
		This algorithm divides the problem into 2 subproblems, thus reducing the problem size by factor 2. Adding several 1-d vectors will cost $O(n)$ operations. Thus, we have the following formula.
		\[
			T(n) = 2T(\frac{n}{2}) + O(n)
		\]
		
		By Master theorem, $T(n) = O(n\log n)$.
		
	\end{enumerate}
\end{enumerate}

 \newpage
  \section{Fastest Winning Strategys}
\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}

\item 

\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Main idea}
		
		The key is to find at least one citizen. 
		
		If there're only 3 or 4 people left, just let them having conversation pairwise and return the person that be reported as citizen the most time to be the candidate of the group. This is the base case. 
		
		Otherwise, split them into two equal size subgroup and invoke this algorithm to find their candidate respectively. Then let these two candidate having conversation with all other person in both groups. Return the candidate that be reported as citizen more times to be the candidate of the combined group. 
		
		
		\item \textbf{Proof of correctness}
		
		Since there're more citizens than werewolves in the beginning, when splitting friends into two equal size subgroups, there exists at least one subgroup that citizen holds majority. Keep focusing on the citizen majority group and keep splitting it. At least 1 base case exists where citizen holds majority. Thus, the candidate reported be this group must be true citizen. When comparing between two subgroups' candidate, if in combined group and one of the subgroups citizen holds majority, the true citizen will be guaranteed be returned as the candidate of the combined group.
		
		\item \textbf{Running time}
		
		There're at most $\log n$ layers. In each layer, $O(n)$ time is needed to comparing between two possible candidate. 
		\[
			T(n) = 2T(\frac{n}{2}) + n
		\]
		
		Therefore, the runtime is $O(n\log n)$
		
	\end{enumerate}




\newpage
	\item Extra Credit 
	
		\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Psedocodes}
		
		The key is to find at least one citizen. Then just let this confirmed citizen having conversation with left $n-1$ friends, and reports whether they're citizen or werewolf. This algorithm finds this citizen recursively. 
		
		
		FIND-CITIZEN($friends$)\{
		
			\qquad $n \leftarrow \operatorname{LEN}(friends)$
		
			\qquad if ($n == 3$ \textbar\textbar\ $n == 4$ )\{
			
				\qquad\qquad Let them have conversation pairwise
				
				\qquad\qquad $werewolf \leftarrow$ the person that be reported as werewolf the most time
				
				\qquad\qquad RETURN anyone from list $friends$ otherthan $werewolf$
								
			\qquad\} else \{
			
				\qquad\qquad $newfriends \leftarrow$  an empty list
			
				\qquad\qquad  for ($i=0;i<n/2;i++$)\{
					
					\qquad\qquad\qquad Let $friends\left[2i\right]$ and $friends\left[2i+1\right]$ have conversation
					
					\qquad\qquad\qquad $result1 \leftarrow$ result be reported by $friends\left[2i\right]$
					
					\qquad\qquad\qquad $result2 \leftarrow$ result be reported by $friends\left[2i+1\right]$
					
					\qquad\qquad\qquad if ( $result1==$ WEREWOLF \textbar\textbar\ $result2==$ WEREWOLF )\{
					
					\qquad\qquad\qquad\qquad continue
					
					\qquad\qquad\qquad \}
					
					\qquad\qquad\qquad Add $friend\left[2i\right]$ to list $newfriends$
				
				\qquad\qquad \}
				
				\qquad\qquad if ( $n$ is odd )\{
				
				\qquad\qquad\qquad Let $friends\left[n-1\right]$ have conversation with all other people in  $friends$
				
				\qquad\qquad\qquad if ( the majority reports $friends\left[n-1\right]$ as CITIZEN) \{
				
				\qquad\qquad\qquad\qquad Add $friends\left[n-1\right]$ to list $newfriends$
				
				\qquad\qquad\qquad \}
								
				\qquad\qquad \}
				
				\qquad\qquad RETURN FIND-CITIZEN($newfriends$)
				
			\qquad\}
			
		\}
		
		\item \textbf{Proof of correctness}
		
		If either person be reported as werewolf within a pair, there're only two possible situations. Either (1) one of them is citizen and the other is werewolf or (2) both of them are werewolves. Therefore, the number of werewolf in $newfriends$ will decrease more than the number of citizen in each iteration. Also, if both person be reported as citizen within a pair, either (1) both of them are citizens or (2) both of them are werewolves. Citizen and werewolf come in pairs, so remove half of them wouldn't sabotage the citizen's majority. If there're more citizens than werewolves in the beginning, this property will hold true for all iterations in this algorithm. Thus, it guarantees there're 2 or 3 citizens and only 1 werewolf in the base case, which can prove the correctness of the confirmed citizen.
		
		\item \textbf{Running time}
		
		In each iteration, at most half of people in  $friends$ will be added to $newfriends$. Therefore, this algorithm has at most $\log n$ layers. In each layer it costs $O(n)$ to  have conversation. So we have the following formula:
		\[
			T(n) = T(\frac{n}{2}) + n
		\]
		
		By Master theorem, $T(n) = O(n)$.
				
	\end{enumerate}



	
\end{enumerate}


\end{document}