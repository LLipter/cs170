% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,geometry,graphicx,enumerate}

\def\Name{Ran Liao}  % Your name
\def\SID{3034504227}  % Your student ID number
\def\Homework{2} % Number of Homework
\def\Session{Spring 2019}


\title{CS170--Spring 2019 --- Homework \Homework\ Solutions}
\author{\Name, SID \SID}
\markboth{CS170--\Session\  Homework \Homework\ \Name}{CS170--\Session\ Homework \Homework\ \Name}
\pagestyle{myheadings}
\date{}

\newenvironment{qparts}{\begin{enumerate}[{(}a{)}]}{\end{enumerate}}
\def\endproofmark{$\Box$}
\newenvironment{proof}{\par{\bf Proof}:}{\endproofmark\smallskip}

\textheight=9in
\textwidth=6.5in
\topmargin=-.75in
\oddsidemargin=0.25in
\evensidemargin=0.25in


\begin{document}
\maketitle
Collaborators: YiLin Wu, YeFan Zhou

\section{Study Group}
\begin{tabular}{ll}
    Name        &   SID         \\\hline
    Ran Liao    &   3034504227  \\  
    YiLin Wu    &   3034503863  \\
    YeFan Zhou  &   3034503824 
\end{tabular}

\newpage
\section{Asymptotic Complexity Comparisons}
\begin{qparts}
\item 
$3 \leq  7 \leq 2 \leq 5 \leq 4 \leq 9 \leq 8 \leq 6 \leq 1$

\item 
\renewcommand{\theenumii}{\roman{enumii}}
\begin{enumerate}
  \item $\log_3n = \Theta(\log_4n)$
  
  Proof:
  \[
	 \log_3n  =  \log_{(4^{\log_4 3})}n = (\frac{1}{\log_4 3})\log_4n = \Theta(\log_4n)
 \]
  \item $n\log(n^4) = O(n^2\log(n^3))$
  
  Proof:
 \[
  	\lim_{n \to +\infty} \frac{n^2\log(n^3)}{n\log(n^4)} = \lim_{n \to +\infty} \frac{3n^2\log n}{4n\log n} = \lim_{n \to +\infty} \frac{3}{4}n = \infty
 \]
 
 \item $\sqrt{n} = \Omega((\log n)^3)$
 
 Proof: (Use L\textquotesingle Hôpital's rule)
 \begin{align*}
 	\lim_{n \to+\infty} \frac{\sqrt{n}}{(\log n)^3} 
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{3(\log n)^2\frac{1}{n}} = \lim_{n \to+\infty} \frac{\sqrt{n}}{(\log n)^2} \\
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{2(\log n)\frac{1}{n}} = \lim_{n \to+\infty} \frac{\sqrt{n}}{\log n} \\
	&= \lim_{n \to+\infty} \frac{\frac{1}{2\sqrt{n}}}{\frac{1}{n}} = \lim_{n \to+\infty} \sqrt{n} = \infty
 \end{align*}
 
 \item $2^n = \Theta(2^{n+1})$
 
 Proof:
 \[
 	2^{n+1} = 2 * 2^n = \Theta(2^n)
 \]
 
 \item $n = \Omega((\log n)^{\log \log n})$
 
 Proof:(Use L\textquotesingle Hôpital's rule)
 
 Take the logarithm of both functions
 \[
 	\log (\log n)^{\log \log n} = (\log \log n)^2
 \]
 Therefore, it is equivalent to compare $(\log \log n)^2$ and $\log n$
 \begin{align*}
 	\lim_{n \to+\infty} \frac{(\log \log n)^2}{\log n} 
	&= \lim_{n \to+\infty} \frac{2(\log \log n)\frac{1}{\log n}\frac{1}{n}}{\frac{1}{n}} = \lim_{n \to+\infty}\frac{2(\log \log n)}{\log n} \\
	&= \lim_{n \to+\infty} \frac{\frac{1}{\log n}\frac{1}{n}}{\frac{1}{n}} = \lim_{n \to+\infty}\frac{1}{\log n} = 0
 \end{align*}
 
 \item $n + \log n = \Theta(n + (\log n)^2)$
 
 Proof:(Use L\textquotesingle Hôpital's rule)
  \begin{align*}
  	\lim_{n \to+\infty} \frac{n + \log n}{n + (\log n)^2}
		&= \lim_{n \to+\infty} \frac{1 + \frac{1}{n}}{1 + 2(\log n)\frac{1}{n}} = \lim_{n \to+\infty}\frac{n +1}{n + 2\log n} \\
		&= \lim_{n \to+\infty} \frac{1}{1 + \frac{2}{n}} = 1
   \end{align*}
   
  \item $\log (n!) = O(n\log n)$
  
  Proof: Since $n\log n = log (n^n)$, it's equivalent to compare $n!$ and $n^n$. Obviously, $n! = O(n^n)$.
 
\end{enumerate}

\end{qparts}

\newpage
\section{In Between Functions}

Disproof:

Consider the following function, this is a counterexample to the claim.
\begin{equation*}
	f(n) = \lfloor 2^{\sqrt{n}} \rfloor 
\end{equation*}

Since for $\forall c>0$
\begin{equation}
	\lim_{n \to+\infty} \frac{\lfloor 2^{\sqrt{n}} \rfloor} {n^c} = +\infty \label{eq4} \
\end{equation}

By \eqref{eq4}, first part of claim doesn't hold. This can be proved by keep using L\textquotesingle Hôpital's rule. 

In the meantime, for $\forall \alpha > 1$
\begin{equation}
	\lim_{n \to +\infty} \frac{\alpha^n}{\lfloor 2^{\sqrt{n}}\rfloor} = +\infty \label{eq5} \
\end{equation}

By \eqref{eq5}, second part of claim doesn't hold. Again, this can be proved similarly with L\textquotesingle Hôpital's rule.


\newpage
\section{Bit Counter}

\begin{tabular}{l | c}
    n	&   \# Total Flips  \\\hline
    1  &   1  \\  
    2  &   4  \\
    3  &   11 \\
    4  &   26 \\
\end{tabular}

There're two stages when counting from 0 to $2^n-1$ for a n-bit counter. 

\begin{itemize}
	\item Stage1 : when most-significant bit is 0
	\item Stage2 : when most-significant bit is 1
\end{itemize}

Suppose $f(n)$ represents the total number of flips need for n-bit long counter. Both in stage 1 and 2, $f(n-1)$ flips is needed to flip all bits to 1 except the most-significant bit. When switching between stage 1 and 2, another $n$ flips is introduced. 1 flip to switch the most-significant bit from 0 to 1. $n-1$ flips needed to switch all other bits to 0. Therefore, we have the following recursive formula:
\[
	f(n) = 2f(n-1) + n
\]
To solve this formula, we keep using it recursively, providing $f(1) = 1$ as base case:
 \begin{align}
 	f(n) 	&= 2f(n-1) + n \nonumber \\
		&= 4f(n-2) + 2(n-1) + n \nonumber \\
		&= 8f(n-3) + 4(n-2) + 2(n-1) + n \nonumber \\
		&= 2^kf(n-k) + 2^{k-1}(n-k+1) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \nonumber \\
		&= 2^{n-1}f(1) + 2^{n-2}(2) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \nonumber  \\
		&= 2^{n-1}(1) + 2^{n-2}(2) + \ldots + 2^2(n-2) + 2^1(n-1) + 2^0(n-0) \label{eq1} 
 \end{align}
Then we multiply \eqref{eq1} by 2:
 \begin{align}
	2f(n) =  2^{n}(1) + 2^{n-1}(2) + \ldots + 2^3(n-2) + 2^2(n-1) + 2^1(n-0) \label{eq2}  
 \end{align}
By \eqref{eq2} - \eqref{eq1}, we have
 \begin{align*}
 	2f(n) - f(n) &= 2^n + 2^{n-1} + \ldots + 2^1 -n \\
	f(n)		&= \frac{2(1-2^n)}{1-2} - n \\
			&= 2^{n+1} - n - 2 \\
			&= \Theta(2^n)
  \end{align*}
  
  \newpage
  \section{Recurrence Relations}
 Master theorem:
 
Suppose $a, b, c \in \mathbb{R}^+$, $b > 1$ and $T(1)=1$

Given
 \begin{equation*}
 T(n) = aT(\frac{n}{b}) + \Theta(n^c),
 \end{equation*}
 
 We have
\[
 T[n]=\left\{
\begin{array}{lcl}
\Theta(n^{\log_ba})      &      & c < \log_ba\\
\Theta(n^c\log_2n)    &      & c = \log_ba\\
\Theta(n^c)     &      & c > \log_ba\\
\end{array} \right. 
\]

\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
	\item 
	Let $a=4, b=2, c=1$. Since $\log_ba = log_2 4 = 2 > c$, $T(n) = \Theta(n^{\log_ba}) = \Theta(n^2)$.
	\item 
	Let $a=4, b=3, c=2$. Since $\log_ba = log_3 4 < c$, $T(n) = \Theta(n^c) = \Theta(n^2)$.
	\item
	\begin{align*}
		T(n) &= T(\sqrt{n}) + 1 \\
			&= T(n^\frac{1}{2^1}) + 1 \\
			&= T(n^\frac{1}{2^2}) + 1 + 1 \\
			&= T(n^\frac{1}{2^k}) + k \\
	\end{align*}
	This recursion process ends when $n^\frac{1}{2^k}$ reaches 2.
	\begin{align*}
		n^\frac{1}{2^k} &= 2 \\
		\frac{1}{2^k} &= \log_n2  \\
		2^k &= \log_2n \\
		k &= \log_2 \log_2n  \\
	\end{align*}
	Therefore, $T(n) = \Theta(\log \log n)$
\end{enumerate}


  \newpage
  \section{Hadamard matrices}
  
\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
	\item 
	\[
		H_0=
		\begin{bmatrix} 
			1 \\
		\end{bmatrix}
	\]
	\[
		H_1=
		\begin{bmatrix} 
			1 & 1 \\ 
			1 & -1 
		\end{bmatrix}
	\]
		\[
		H_2=
		\begin{bmatrix} 
			1 & 1 & 1 & 1 \\ 
			1 & -1 & 1 & -1 \\ 
			1 & 1 & -1 & -1 \\
			1 & -1 & -1 & 1 \\
		\end{bmatrix}
	\]
	
	\item 
	\[
		H_2v = 
		\begin{bmatrix} 
			1 & 1 & 1 & 1 \\ 
			1 & -1 & 1 & -1 \\ 
			1 & 1 & -1 & -1 \\
			1 & -1 & -1 & 1 \\
		\end{bmatrix}
		\begin{bmatrix} 
			1  \\ 
			-1  \\ 
			-1  \\
			1  \\
		\end{bmatrix}
		=
		\begin{bmatrix} 
			0  \\ 
			0  \\ 
			0  \\
			4  \\
		\end{bmatrix}
	\]
	
	\item 
	\begin{align*}
		u_1 &= H_1(v_1 + v_2) \\
			&= 
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				(
				\begin{bmatrix} 
					1  \\ 
					-1 \\
				\end{bmatrix}
				+
				\begin{bmatrix} 
					-1  \\ 
					1 \\
				\end{bmatrix}	
				)	\\	
			&= 	
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				\begin{bmatrix} 
					0  \\ 
					0 \\
				\end{bmatrix}	\\
			&= 
				\begin{bmatrix} 
					0  \\ 
					0 \\
				\end{bmatrix}					
	\end{align*}
	\begin{align*}
		u_2 &= H_1(v_1 - v_2) \\
			&= 
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				(
				\begin{bmatrix} 
					1  \\ 
					-1 \\
				\end{bmatrix}
				-
				\begin{bmatrix} 
					-1  \\ 
					1 \\
				\end{bmatrix}	
				)	\\	
			&= 	
				\begin{bmatrix} 
					1 & 1 \\ 
					1 & -1 
				\end{bmatrix}
				\begin{bmatrix} 
					2  \\ 
					-2 \\
				\end{bmatrix}	\\
			&= 
				\begin{bmatrix} 
					0  \\ 
					4 \\
				\end{bmatrix}					
	\end{align*}
	\[
		u =
		\begin{bmatrix}
			u_1 \\
			u_2 \\
		\end{bmatrix}
		=
		\begin{bmatrix}
			0 \\
			0 \\
			0 \\
			4 \\
		\end{bmatrix}		
	\]
	
	$u$ is identical to $H_2v$
	
	\item
	\begin{align}
		H_kv &= 			
				\begin{bmatrix} 
					H_{k-1} & H_{k-1} \\ 
					H_{k-1} & -H_{k-1} \\ 
				\end{bmatrix}
				\begin{bmatrix}
					v_1 \\
					v_2 \\
				\end{bmatrix} \nonumber \\
			&= 
				\begin{bmatrix} 
					H_{k-1}v_1 + H_{k-1} v_2 \\ 
					H_{k-1}v_1 - H_{k-1} v_2 \\ 
				\end{bmatrix} \label{eq3} 	\\
			&= 		
				\begin{bmatrix} 
					H_{k-1}(v_1 + v_2)  \\ 
					H_{k-1}(v_1 - v_2) \nonumber   \\ 
				\end{bmatrix}	
	\end{align}
	
	\item
	
	\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Main idea}
		
		This is a recursive algorithm. 
		
		If the length of $v$ is 1, just return $H_0v$ immediately. This is the base case.
		
		Otherwise, let $v_1$ and $v_2$ be the top and bottom half of the vector $v$, respectively. Invoke this algorithm recursively to compute $H_{k-1}v_1$ and $H_{k-1}v_2$. Return $									\begin{bmatrix} 
					H_{k-1}v_1  + H_{k-1}v_2\\ 
					H_{k-1}v_1  -  H_{k-1}v_2 \\ 
				\end{bmatrix}$ as result.
		\item \textbf{Proof of correctness}
		
		By \eqref{eq3}, this strategy is correct mathematically.
		\item \textbf{Running time}
		
		This algorithm divides the problem into 2 subproblems, thus reducing the problem size by factor 2. Adding several 1-d vectors will cost $O(n)$ operations. Thus, we have the following formula.
		\[
			T(n) = 2T(\frac{n}{2}) + O(n)
		\]
		
		By Master theorem, $T(n) = O(n\log n)$.
		
	\end{enumerate}
\end{enumerate}

 \newpage
  \section{Fastest Winning Strategys}
\renewcommand{\labelenumi}{(\alph{enumi})}
\begin{enumerate}
	\item
	
		\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Main idea}
		
		The key is to find at least one citizen. Then just let this confirmed citizen having conversation with left $n-1$ friends, and report whether they're citizen or werewolf. This algorithm finds this citizen recursively. 
		
		Psedocodes:
		
		FIND-CITIZEN($friends$)\{
		
			\qquad $n \leftarrow \operatorname{LEN}(friends)$
		
			\qquad if ($n == 3$ \textbar\textbar\ $n == 4$ )\{
			
				\qquad\qquad Let them have conversation pairwise
				
				\qquad\qquad $werewolf \leftarrow$ the person that be reported as werewolf the most time
				
				\qquad\qquad RETURN anyone from list $friends$ otherthan $werewolf$
								
			\qquad\} else \{
			
				\qquad\qquad $newfriends \leftarrow$  a empty list
			
				\qquad\qquad  for ($i=0;i<n/2;i++$)\{
					
					\qquad\qquad\qquad Let $friends\left[2i\right]$ and $friends\left[2i+1\right]$ have conversation
					
					\qquad\qquad\qquad $result1 \leftarrow$ result be reported by $friends\left[2i\right]$
					
					\qquad\qquad\qquad $result2 \leftarrow$ result be reported by $friends\left[2i+1\right]$
					
					\qquad\qquad\qquad if ( $result1==$ WEREWOLF \textbar\textbar\ $result2==$ WEREWOLF )\{
					
					\qquad\qquad\qquad\qquad continue
					
					\qquad\qquad\qquad \}
					
					\qquad\qquad\qquad Add $friend\left[2i\right]$ to list $newfriends$
				
				\qquad\qquad \}
				
				\qquad\qquad if ( $n$ is odd )\{
				
				\qquad\qquad\qquad Let $friends\left[n-1\right]$ have conversation with all other people in  $friends$
				
				\qquad\qquad\qquad if ( the majority reports $friends\left[n\right]$ as CITIZEN) \{
				
				\qquad\qquad\qquad\qquad Add $friends\left[n-1\right]$ to list $newfriends$
				
				\qquad\qquad\qquad \}
								
				\qquad\qquad \}
				
				\qquad\qquad RETURN FIND-CITIZEN($newfriends$)
				
			\qquad\}
			
		\}
		
		\item \textbf{Proof of correctness}
		
		If either person be reported as werewolf within a pair, there're only two possible situations. Either (1) one of them is citizen and the other is werewolf or (2) both of them are werewolves. Therefore, the number of werewolf in $newfriends$ will decrease more than the number of citizen in each iteration. If there're more citizens than werewolves in the beginning, this property will hold true for all iterations in this algorithm. Thus, it guarantees there're 2 or 3 citizens and only 1 werewolf in the base case, which can prove the correctness of the confirmed citizen.
		
		\item \textbf{Running time}
		
		In each iteration, at most half of people in  $friends$ will be added to $newfriends$. Therefore, this algorithm has at most $\log n$ layers. In each layer it costs $O(n)$ to  have conversation. In total, the runtime should be $O(n\log n)$.
		
	\end{enumerate}

\item Extra Credit 

\renewcommand{\theenumii}{\roman{enumii}}
	\begin{enumerate}
		\item \textbf{Main idea}
		
		Again, the key is to find at least one citizen. Just randomly pick a person from all friends and let him having conversation with all other friends. If the majority reports him as citizen, just return him. Otherwise, just randomly pick another person and try it again.
		
		
		
		\item \textbf{Proof of correctness}
		
		There're more citizens than werewolves in friends, therefore, the person returned by this algorithm must be a real citizen.
		
		\item \textbf{Running time}
		
		There're more citizens than werewolves in friends, therefore, on average we could find this citizen within first 2 tries. So the runtime is $O(2n) = O(n)$ 
		
	\end{enumerate}

	
\end{enumerate}


\end{document}